\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on function pointers}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3327R0 \\
Date: &2024-06-25 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R7} that would allow placing function contract assertions --- \tcode{pre} and \tcode{post} --- directly on pointers to functions and pointers to member functions. We identify two possible choices regarding the basic semantics --- enforcing that the pointer and the function have the same sequence of function contract assertions, or allowing them to be different, meaning that the pointer has its own contract. We then identify three apparent design directions for integrating such a feature into the language --- making the function contract assertions a property of the function type, of the pointer value, or of the pointer object. We analyse all three approaches and highlight the shortcomings of each. We conclude that any design that allows placing function contract assertions directly on pointers to functions and pointers to member functions would necessarily have significant limitations, and that we should consider instead specifying the desired functionality as a separate, new language feature, such as the \emph{function usage types} proposed in \cite{P3271R0}.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Motivation}
\label{sec:intro}

The current proposal \cite{P2900R7} for adding a Contracts facility to C++ --- the so-called \emph{Contracts MVP proposal} --- does not allow function contract assertions, \tcode{pre} and \tcode{post}, to be attached to a pointer to function or pointer to member function. However, it specifies that when a function is invoked through a pointer to function or pointer to member function, the function contract assertions specified on that function itself are still evaluated as normal.

It has been suggested in \cite{P3173R0} that ``a Contracts facility that fails to adequately support efficient use with [...] pointer to functions is woefully inadequate and unready for prime use'', however the paper fails to provide even a sketch of a specification of how such support of pointers to functions --- beyond the current specification in the Contracts MVP --- could actually work.

It has been further suggested that if we can figure out how to support function contract assertions on \emph{virtual functions} (an extension to \cite{P2900R7} that SG21 is currently actively working on, see \cite{P3097R0} and \cite{P3165R0}), then it should become apparent how to support function contract assertions on function pointers as well, or vice versa, as these two possible extensions have similarities and/or should be made consistent with each other. Some people have even gone as far as saying that they are \emph{isomorphic}, as the framework of \emph{interface contracts} and \emph{implementation contracts} can be conceptually applied to both kinds of indirect calls in the same way. However, whether \tcode{pre} and \tcode{post} on pointers to functions could actually be made to work in such a framework, and if so, how, has so far not been demonstrated.

To inform these ongoing discussions, the present paper provides an exploration of the available design space for placing \tcode{pre} and \tcode{post} on pointers to functions and pointers to member functions. The goal of the paper is to map out the different options in the design space and their tradeoffs, and to highlight which questions any concrete proposal to add support for function contract assertions on pointers to functions and pointers to member functions must answer in order to be viable. Our exploration focuses on pointers to functions, however all aspects of this exploration apply equally to pointers to member functions.

We begin our exploration with considering the semantics --- what does it \emph{mean} when a pointer has function contract assertions, and what should be the \emph{behaviour}? Are these function contract assertions the same as those of the function the pointer points to, or are they separate? If the function contract assertions of the pointer are different from those of the function it points to, how could entities with different function contract assertions be made interoperable, what rules could we apply to conversions between them, and when and in what order would the different involved contract assertions be evaluated?

We then consider how function contract assertions on pointers could actually be specified and  integrated into the language. There are three apparent options --- making these assertions a property of the function type, of the pointer value, or of the pointer object. We will discuss all three options, and how different semantics could be implemented with each option.

We deliberately do not explore the \emph{syntactic} space --- how could we \emph{spell} function contract assertions on a function pointer? --- in much detail in this paper as we consider the syntax secondary to the semantic and conceptual concerns. 

Note that none of these ideas are novel. Support for contract assertions on function pointers has been considered multiple times in past proposals for a C++ Contracts facility. Each time, the idea for providing such support was eventually dropped from the proposal. In the following discussion, we will provide references to these past proposals where appropriate.

\section{Contracts on indirect calls}

Consider a function that has function contract assertions (\tcode{pre} and \tcode{post}):
\begin{codeblock}
int f(int i)
  pre (i % 2 == 0)        // must call with even integer
  post (r: r % 2 == 0);   // guaranteed to return even integer
\end{codeblock}
Now let us assume that we can define a pointer \tcode{fp} to a function with the same signature as \tcode{f}, and that we can specify function contract assertions that apply to \tcode{fp} (ignoring, for now, the question whether the syntax we use below would actually work with the C++ grammar):
\begin{codeblock}
int (*fp)(int i) 
  pre (i > 0)        // must call with positive integer
  post (r: r != 0);  // guaranteed to return non-zero integer
\end{codeblock}
Now, what should happen when we initialise \tcode{fp} with the address of \tcode{f}, or assign the address of \tcode{f} to \tcode{fp}, and then call \tcode{f} through \tcode{fp}?
\begin{codeblock}  
void test(int i) {
  fp = f;    
  fp(i);
}
\end{codeblock}
\subsection{Interface and implementation contracts}
\label{subsec:interimpl}

We start by introducing some definitions that will be helpful for the remainder of this discussion. In particular, let us conceptually separate the overall contract that applies to a function call into the \emph{interface contract} and the \emph{implementation contract}. Note that this conceptual separation is identical to the one we introduced in \cite{P3097R0} in the context of virtual function calls.

First, note that a function can be called either \emph{directly} or \emph{indirectly}. A virtual function call and a call through a pointer to function are both forms of an indirect call that are part of the core language.\footnote{Note that there are other forms of indirect calls, such as a call through \tcode{std::function}, however those are typically not part of the core language but under the hood will use to forms of indirect calls that are part of the core language, such as virtual function calls or calls through a pointer to function.}

The \emph{interface contract} is the contract known at the call site of the function in question. For a virtual function call, the interface contract is that of the statically called function; for a function call through a pointer, the interface contract is that of the pointer; for a direct function call, the interface contract is simply the contract of the called function.

The \emph{implementation contract} is the contract known to the definition of the function that ends up being called, i.e. whose function body ends up being executed as the result of the call. For a virtual function call, the implementation contract is the contract of the final overrider; for a function call through a pointer, the implementation contract is the contract of the function currently pointed to by the pointer; for a direct function call, the implementation contract is simply the contract of the called function.

Note that for a direct function call, the interface and implementation contracts are always the same contract, but that this is not necessarily so for indirect calls. Note further that when calling a virtual function via a fully qualified call, such a call is not a virtual function call, and is therefore a direct call, not an indirect call.

One important aspect of these concepts is that we define interface and implementation contract in terms of where in the code that contract is visible, not in terms of where the actual checks will be laid down when generating the binary (caller-side or callee-side); we consider the latter to be merely an implementation detail.

\pagebreak  % MANUAL %%%%%%%%

For indirect calls, which have both an interface contract and an implementation contract, the reasonable expectation is that if those contracts are specified via function contract assertions --- \tcode{pre} and \tcode{post} --- then the function contract assertions corresponding to the interface contract are those that apply to the statically called function (in a virtual function call) or to the pointer (in an indirect call through a pointer), and are evaluated whenever a call happens through these interfaces, and the function contract assertions corresponding to the implementation contract are those that apply to the function that ends up being called, and are evaluated whenever that function ends up being called, regardless through which interface this happens.

The status quo in the Contracts MVP \cite{P2900R7}, is that for an indirect function call via a pointer to function, it is impossible to specify the interface contract with function contract assertions, as these are not allowed on a function pointer. In this paper, we explore ways in which this limitation can be extended.

Now, there are fundamentally two ways in which the semantics for such an indirect call through a function pointer could be specified. We could either allow the interface and implementation contract to be different and independent from each other, or we could enforce that the interface contract and the implementation contract are the same contract, as is the case for direct function calls. Both possibilities have implications that we will discuss in Section~\ref{sec:semantics}.

\subsection{Intermediate contracts}
\label{subsec:intermed}

If we allow interface and implementation contracts to differ, another semantic question arises: should \emph{intermediate contracts} be considered?

For virtual functions, an intermediate contract is the contract on a function that sits between the interface (the statically called function) and the implementation (the final overrider) in the inheritance hierarchy. In languages such as D and Eiffel, function contract assertions that specify such intermediate contracts are evaluated as well, because the contracts of any overridden functions are considered to also be part of the contract of the overriding functions, according to the classic Design by Contract mantra that ``preconditions can only be widened and postconditions can only be narrowed'' when overriding a function.

By contrast, the model proposed for C++ in \cite{P3097R0} and \cite{P3165R0}, purposefully does \emph{not} follow that mantra, in order to better support the  use cases that arise when one wants to use contract assertions with the more flexible virtual function mechanism of C++, which does not necessarily always follow traditional object-oriented design. In that model, intermediate contracts are not considered, because they are not involved in the indirect call in any way: if \tcode{C} inherits from \tcode{B}, and \tcode{D} inherits from \tcode{C}, and we call \tcode{D::f()} through a pointer or reference to \tcode{B}, then we use the \emph{interface} \tcode{B::f()} (so we should check its contract) to call the \emph{implementation} \tcode{D::f()} (so we should check its contract, too), but we do not use \tcode{C::f()} in any way so there is no reason to check the contract of that function. This model also seamlessly supports multiple inheritance, something that is not possible with classic Design by Contract (see discussion in \cite{P3097R0}).

For pointers to function that are allowed to have their own, distinct contract, intermediate contracts exist when we have a chain of assignments to such pointers, for example:
\begin{codeblock}
	
void f(int i) pre(i !=0 );             // must call with non-zero number
void (*fp1)(int i) pre (i % 2 == 0);   // must call with even number 
void (*fp2)(int i) pre (i > 0);        // must call with positive number

fp1 = f;
fp2 = fp1;
fp2(3);   // should this be a contract violation?
\end{codeblock}
Here, the contract of \tcode{fp1} acts as the intermediate contract. We can ask ourselves whether we consider a call of \tcode{f} through \tcode{fp2} in a way that violates the contract of \tcode{fp1} a contract violation, i.e. a bug, and therefore wish for the function contract assertions of \tcode{fp1} to be evaluated in this call, or not. 

On the one hand, it seems like \tcode{fp1} is not part of this call, so it is irrelevant and should not be considered, like in the \cite{P3097R0} model for virtual functions; on the other hand, we obtained the value of \tcode{fp2} \emph{through} \tcode{fp1}, so one could argue that silently dropping any requirements and guarantees provided by the contract of \tcode{fp1} after assigning its value to a different pointer might not match the intent of the code above.

Note that the situation seems isomorphic to intermediate contracts on virtual functions in an inheritance hierarchy, but there is an important difference that has a huge impact on possible implementation strategies: while the inheritance hierarchy, and thus the function contract assertions of all overridden functions in the chain, is fully known at compile time, the same is not generally true for pointers whose value can change at runtime, unless we make runtime conversions between pointers with different function contract assertions ill-formed, a possibility we discuss in Section~\ref{subsec:conv}.

\section{Possible semantics}
\label{sec:semanics}

\subsection{Pointer can have contract different from the function}
\label{subsec:diffcontract}

The first possible design direction is to allow the interface contract and the implementation contract to be different, independent contracts. This means that a function and a pointer to that function can have their own, independent sequences of function contract assertions, which will be evaluated separately. 

The ability to specify interface and implementation contracts separately is important for a number of use cases. Consider for example some numerical algorithm \tcode{crunchNumbers} that takes a pointer to function and has a precondition that this function, when called, only returns positive numbers. This can be expressed as an interface contract on the pointer to function:
\begin{codeblock}
void crunchNumbers(int (*positiveGenerator)() post (r : r > 0)) {
  // do stuff with positive numbers returned by \tcode{positiveGenerator}...
}
\end{codeblock}
Now, we might pass different functions into \tcode{crunchNumbers}, which might do different things, and therefore have their own, distinct contracts:
\begin{codeblock}
// This function produces only multiples of three
int f1() post (r: r % 3 == 0);

// This function produces only prime numbers
int f2() post (r: isPrime(r));

// etc.
\end{codeblock}
Now, if we pass \tcode{f1}, \tcode{f2}, etc. into \tcode{crunchNumbers}, which will call these functions through the pointer \tcode{positiveGenerator}, then the function contract assertions of \tcode{positiveGenerator} specify the interface contract, and the function contract assertions of \tcode{f1}, \tcode{f2}, etc. specify the implementation contract.

Note that the interface and implementation contracts are completely independent from each other. The functions \tcode{f1}, \tcode{f2}, etc. do not guarantee, in general, that the number returned is always positive (it is not part of the implementation contract); however, \tcode{crunchNumbers} must call those
functions only in ways where they end up producing positive numbers, otherwise the program contains a bug (a violation of the interface contract). 

In order to make sure that all of these components are being used together correctly, and catch any such bugs, both sets of function contract assertions need to be evaluated. This raises the question in which order these evaluations should happen. The only order that seems to make sense is:
\begin{enumerate}
\item Evaluate the interface precondition assertions,
\item Evaluate the implementation precondition assertions,
\item Execute the body of the function,
\item Evaluate the implementation postcondition assertions,
\item Evaluate the interface postcondition assertions.
\end{enumerate}
Note that this seems isomorphic to interface and implementation contracts on virtual functions as proposed in \cite{P3097R0} and \cite{P3165R0}.

While the above semantics certainly seem useful, the question remains whether it is actually possible to specify and implement a feature that works this way. Unfortunately, if the interface is a pointer to function or a pointer to member function, it is not straightforward at all how this could be achieved. We explore the possible specification strategies in Section~\ref{sec:specstrat}.

\subsection{Pointer must have the same contract as the function}
\label{subsec:samecontract}

An alternative design direction is to not allow the interface contract (on the pointer) and the implementation contract (on the function) --- as well as any intermediate contracts if we wish to consider them --- to be different from each other, and instead to enforce that they are always the same, as for a direct call. This would mean that all of the above code examples would be incorrect, as the contracts do not match, and should be specified as ill-formed (or, alternatively, as undefined behaviour or erroneous behaviour, although this seems less desirable).

This design direction restricts the ways in which functions with contract assertions and pointers can be used together, and does not support use cases such as the one described in Section~\ref{subsec:diffcontract}. This seems unfortunate as it means that there will be more situations in which the contracts of the program cannot be checked with contract assertions, and thus the code cannot be made safer. 

This design direction also does not support even basic use cases such as passing a pointer to function that has function contract assertions to a legacy API that expects a pointer to function without such assertions. This is especially unfortunate because function pointers are particularly common in code that interacts with such legacy APIs --- in a codebase written entirely in modern C++, indirect call mechanisms more ergonomic than pointers to function and pointers to member function are readily available.

However, the tradeoff is that  this design direction might make it easier to specify and implement an extension that allows function contract assertions on pointers to function (see Section~\ref{sec:specstrat}). Compared to the status quo in \cite{P2900R7}, such an extension would a mechanism to enable caller-side checking of the precondition and postcondition assertions declared on the function in cases where this would not be possible with the status quo. Consider:
\begin{codeblock}
void f(int x) pre(x >= 0);
void g(void (*fp)(int x) pre (int x >=0)); // definition in another TU

void usingCode() {
   void (*fp)(int x) pre(x >= 0) = f;
   g(fp);
}
\end{codeblock}
In this scenario, the definition of \tcode{g} might not know that the function that ends up being called is \tcode{f}, and might not see its declaration and its function contract assertions. However, by using the pointer \tcode{fp} that has a matching sequence of function contract assertions, \tcode{g} is still able to perform caller-side checking of \tcode{f}'s function contract assertions if this is desired by the owner of the program. In essence, this gives us a way to propagate information about the function contract assertions of \tcode{f} to other parts of the program separately from the declaration of \tcode{f} itself.

It is somewhat unclear how useful this design would actually be in practice. It seems that a function pointer that is required to have the same sequence of function contract assertions as any function that it can point at would only be particularly useful if we were dealing with a whole group of functions that all have the same contract. However, any two functions that are supposed to do different things will normally have different contracts. Consider two functions \tcode{f1} and \tcode{f2}. If \tcode{f1} and \tcode{f2} have the exact same preconditions and postconditions, then it follows that \tcode{f1} and \tcode{f2} have the same essential behaviour, and thus are actually the same function.

For example, consider two functions, \tcode{sqrt} and \tcode{fourthrt}, computing the square root and fourth root of a real number, respectively. At first glance, it seems that you might want to apply the same sequence of function contract assertions to both functions --- they both require a positive number and return a positive number:
\begin{codeblock}
float sqrt (float x)     pre (x > 0) post (r : r > 0);
float fourthrt (float x) pre (x > 0) post (r : r > 0);
\end{codeblock}
However, if we consider the full contract of these functions, we realise that there are additional postconditions that are different between the two, and could potentially be expressed with the following postcondition assertions (ignoring for a moment the limitations of floating point precision):
\begin{codeblock}
float sqrt (float x) post (r : r * r == x);
float fourthrt (float x) post (r : r * r * r * r == x);
\end{codeblock}
It is conceivable that there might be cases where \tcode{f1} and \tcode{f2} are distinct functions, and therefore have different contracts, but the subset of \tcode{f1}'s contract that can be expressed via precondition and postcondition assertions might be identical to the corresponding subset of \tcode{f2}'s contract, and the ``function contract assertions must be the same'' model can be applied to those functions. An example of this are two functions \tcode{f1} and \tcode{f2} that are guaranteed to return the same value given the same input, but differ in their guaranteed side effects (for example, one is specified to perform logging while the other is not), and those side effects are not easily checkable with contract assertions. Note however that future extensions to Contracts might introduce new and more powerful ways to express function contract assertions, such as \emph{procedural interfaces} as proposed in \cite{P0465R0}, which will make it less likely that two different functions that are supposed to do different things could end up having the exact same function contact assertions.

As a separate concern, requiring to repeat the function contract assertions on each pointer makes it more laborious to make the code compile, and makes the code itself more verbose, since the user is required to repeat the function contract assertions everywhere where there is a pointer that might point to that function.

This design direction was proposed in a series of papers from the early C++2a Contracts era: \cite{N4415}, \cite{P0287R0}, and \cite{P0380R0}. In these papers, function contract assertions could be placed directly on pointers to function, but assigning a function to such a pointer, or assigning the value of a pointer to function to another such pointer, was ill-formed unless the function contract assertions on both entities match.

The motivation given in those papers was actually not to enable caller-side checking, but to guarantee that when a function is called through a pointer, its function contract assertions are still checked. However, in  revision \cite{P0380R1} it was realised that there is a much more effective way to achieve this, without placing undue burden on the user: we can specify that when a function is called through a pointer, its own function contract assertions are still evaluated as if it was called directly. This effectively introduced interface and implementation contracts as defined in Section~\ref{subsec:interimpl} above, except that the interface contract of a function pointer is empty for now (or, to be more precise, cannot yet be specified with function contract assertions); this specification is still the status quo in the Contracts MVP \cite{P2900R7} today.

\subsection{Conversions between different contracts}
\label{subsec:conv}

In the above sections, we discussed two extremes of the possible design spectrum: that the function contract assertions of a function and any pointer pointing to it must be statically guaranteed to always be the same, or that the function contract assertions of a function and any pointer pointing to it are entirely independent and evaluated separately. However, there are some plausible in-between directions which have the potential to support more use cases than the very restrictive ``all involved function contract assertions must be the same'' model.

In particular, we could allow dropping the function contract assertions when assigning to a function pointer, while not allowing other contract assertion mismatch scenarios. This would allow us to pass such a pointer into a legacy API --- an important use case. However, we would need to specify whether the function contract assertions would still be evaluated in this case. On the one hand, dropping these evaluations could open up a safety risk; on the other hand, retaining them has significant implications for a possible implementation strategy, as we will see in the next section.

Another option would be to allow converting between two pointers with different function contract assertions, but to guarantee some relation between them, for example that ``preconditions can only be widened and postconditions can only be narrowed'', as is done in classic Design by Contract for virtual functions. By analogy, we could either implement such subsumptions by ``OR-ing preconditions and AND-ing postconditions'', but this would require implementing support for checking intermediate contracts (see Section~\ref{subsec:intermed}), or we could entertain performing static subsumption proofs. The feasibility of such proofs is questionable at best, and therefore we do not believe that this direction is viable with current C++ compiler technology. It seems further that the classic Design by Contract mantra is not a good fit for C++ with its highly flexible indirect call mechanisms and its multi-paradigm ecosystem --- a conclusion discussed in more detail in \cite{P3097R0}.
\section{Possible specification strategies}
\label{sec:specstrat}

In order to be able to evaluate the function contract assertions attached to a pointer to function whenever any function is called through that pointer (regardless of whether or not we allow the function itself to have a distinct sequence of function pointer assertions), information about these contract assertions has to be encoded \emph{somewhere} in the program.

There are three potential places where this information can be stored --- in the type system, in the value representation, or in the object model. In other words, the contract assertions attached to the pointer can be a property of the function type, of the pointer value, or of the pointer object. Choosing any of these three strategies has wide-reaching consequences which we will discuss below.

\subsection{Make \tcode{pre} and \tcode{post} a part of the type system}
\label{subsec:maketype}

If the function contract assertions that apply to a pointer to function are part of the function type, this means that two pointers that have a different sequence of function contract assertions would be of different type, even if they are otherwise the same (again, ignoring for the purposes of this discussion whether the below syntax would actually work):
\begin{codeblock}
void(*fp1)(int i) pre (i > 0);
void(*fp2)(int i) pre (i != 0);
static_assert(std::is_same_v<decltype(fp1), decltype(fp2)>);  // must be \tcode{false}
\end{codeblock}
Since the address of a function is itself a function pointer, any attempt to make contract assertions part of the type system would have to do so consistently --- meaning that the types of \emph{functions} with a different sequence of function contract assertions would have to be different, too:
\begin{codeblock}
void f1(int i) pre (i > 0);
void f2(int i) pre (i != 0);
static_assert(std::is_same_v<decltype(f1), decltype(f2)>);  // must be \tcode{false}
\end{codeblock}
Introducing such an observable change in type would directly violate several key design principles of \cite{P2900R7}.

First, in order to ensure seamless adoption of Contracts, if we add function contract assertions to the declaration of a pre-existing function that does not have such assertions, and the new declaration compiles correctly, then all \emph{correct} uses of that function should also still compile, and should have the same compile-time semantics and runtime behaviour as they had before, except that the new contract assertions are now being evaluated; if we make function contract assertions part of the type system, this property would no longer hold.

Second, making function contract assertions part of the type system would make them visible to Concepts and other forms of compile-time branching, and thus make it possible that adding a contract assertion to an existing program alters the correctness of that program, undermining the fundamental purpose of the proposed Contracts facility.

Note that this is true regardless of whether we allow function pointers to have function contract assertions distinct from the function they are pointing to, and/or distinct from other pointers pointing to the same function.

There are numerous other problems with the type system approach. For example, what should \tcode{operator \&} do, and how should that will interact with type deduction? If we were to ever have \tcode{operator \&} changed to return ``pointer to function with that function's contract assertions'', this would break code like the following:
\begin{codeblock}
void f1() post (r: r > 0);
void f2() post (r: r < 0);

void x() {
  auto* f = &f2;   // pointer with assertion \tcode{post (r: r > 0)}
  if (rand()) {
    f = &f1;  // assigning to a function with a different, incompatible postcondition
  }
  f();  // violation if branch was taken! Certainly not the intent of the original code.
}
\end{codeblock}
But the most severe practical consequence of making the function contract assertions part of the type system would be that this would necessarily lead to an explosion of types. As we already discussed in Section~\ref{subsec:samecontract}, any two functions that are supposed to do different things will normally have different contracts: if they have the same contract, then it follows that they have the same essential behaviour, and thus are, in most cases, the same function. The consequence is that practically every function with function contract assertions will have its own unique type. Any template that takes a function type as a template argument --- consider \tcode{std::sort} or \tcode{std::map} --- would have a separate instantiation for each function provided, leading to significant code bloat that many users will find unacceptable. Making \tcode{noexcept} a part of the type system has --- in the worst case --- doubled the amount of template instantiations; making the function contract assertions a part of the type system would be much worse than that.

Further, the compiler would have to do additional work whenever we use a function type with function contract assertions as a template parameter, and/or whenever it needs to be determined whether two function types are the same. It follows that the sequence of function contract assertions must inevitably become a part of the name mangling. This would also make them an explicit part of the ABI --- another complication with wide-ranging consequences that \cite{P2900R7} explicitly seeks to avoid.

Finally, the question arises whether making function contract assertions a part of the function's type would mean that you could \emph{overload} on different function contract assertions., and if so, how the overload resolution would work in this case:
\begin{codeblock}
void f(void (*)(int x) pre(x == 0));  // Overload 1
void f(void (*)(int x) pre(x > 0));   // Overload 2

void r(int x) pre(x == 0);
void s(int x) pre(x > 0);
void t(int x);
void u(int x) pre(x == 0) pre(x == 0);
void v(const int x) pre(x == 0) post(x == 0);

f(&r);  // which f overload is called? Overload 1 seems likely
f(&s);  // which f overload is called? Overload 2 seems likely
f(&t);  // now what?
f(&u);  // ...and now?
f(&v);  // ...and now?
\end{codeblock}
We could also consider making declaring two functions with the same name and signature but different function contract assertions be ill-formed, as it is the case today for two functions that only differ in whether they are \tcode{noexcept(true)} or \tcode{noexcept(false)}, to avoid contract assertions becoming part of overload resolution, but that might limit the use cases that such a feature could satisfy.

Ultimately, it seems that for all of the above reasons making function contract assertions an explicit part of the type system is not a viable strategy. This has been realised as early as in \cite{N4110} --- an exploration of the Contracts design space published in 2014 that mentioned many of the thoughts covered above --- and reiterated in \cite{N4415}, \cite{P0246R0}, \cite{P0247R0}, \cite{P0287R0}, \cite{P0380R1}, and \cite{P0542R5}.

\subsection{Encode \tcode{pre} and \tcode{post} in the pointer value}
\label{subsec:makevalue}

If we cannot encode the function contract assertions applied to a pointer to function in the type of the function or the pointer, the next option is to encode this information in the pointer value. Right off the bat this seems to be a less natural choice: the function contract assertions that apply to a pointer to function are usually thought of as a static property (just like the function contract assertions that apply to a \emph{function} are a static property), however the value of a pointer is a dynamic property that can change at runtime and therefore requires runtime space and time resources.

Nevertheless, let us consider how we could make the function contract assertions that apply to a pointer a property of that pointer's value.

One option would be to generate a thunk that checks the interface contract assertions and then calls the underlying function, and to store the address of that thunk in the pointer. This approach  invalidates the assumption that the value of the pointer is the equal to the address of the function it points to.\footnote{While the C++ Standard tries to guarantee this, in practice, there are already cases where this assumption is invalidated, so this does not seem like the biggest obstacle. For example, if you use dynamic linking, load a function \tcode{f} from a dynamic library, and ask for the address of \tcode{f}, you will in practice get two different answers inside and outside of that dynamic library.} Moreover, it requires devising a strategy for when to allocate and deallocate those thunks. Depending on the semantics we wish to support (allow pointers to have function contract assertions different from the function they point to and/or other pointers that might point to that function, checking intermediate contracts, etc.), we might be able to allocate all possible thunks statically, or we might have to do this dynamically, raising questions about how we would then deallocate them, given that there might not be a general way to keep track of the lifetime of those thunks.

Alternatively, we could consider somehow encoding the assertions directly in the object representation of the pointer. However, that would inevitably mean that the pointer value will no longer fit into a pointer-sized chunk of memory (8 bytes on a 64-bit system). Further, since the sequence of function contract assertions and the complexity of the predicate expressions is unbounded, we could never encode the \emph{entire} information directly in the object representations (otherwise, what would \tcode{sizeof(fp)} be?), and would have to partially place it outside, which effectively means that we will end up with something similar to the thunk approach anyway.

Whichever way we would implement the interface contract as part of the pointer value, using such an approach would inevitably incur overhead both in code size and in runtime (due to the additional indirection) compared to the other approaches, and would further necessitate non-backwards-compatible ABI changes. This violates another important design principle of \cite{P2900R7} --- that at least \emph{unchecked} contract assertions should never impose overhead --- and many users would find such a tradeoff unacceptable.

We can conclude that an indirection mechanism that treats the interface contract assertions as a dynamic property could potentially be useful, but seems so substantially different in semantics from the current notion of \emph{pointer to function} that it should be a separate feature, and should be spelled differently.

\subsection{Make \tcode{pre} and \tcode{post} a property of the pointer object}
\label{subsec:makeobject}

The final possibility for encoding the information needed to specify function contract assertions that apply to a pointer to function is to make these assertions a property of the pointer object. This means that this information is neither part of the type, nor part of the value, but only exists in an ephemeral fashion in the compiler's AST while the program is being compiled. This strategy has been proposed in \cite{P0246R0} and \cite{P0247R0}, but this direction was later abandoned (the papers do not discuss why); nevertheless, it is worth taking another look at this strategy and its consequences.

Consider the following code:

\begin{codeblock}
void f(int i);

void test(int i) {
  void(*fp)(int i) pre (i > 0) = f;
  fp(i);
}
\end{codeblock}
With this strategy, the type of \tcode{fp} would still be just ``pointer to function that takes \tcode{int} and returns \tcode{void}'', and the value of \tcode{fp} would still be just ``address of \tcode{f}'', but because the user added a precondition assertion to the declaration of \tcode{fp}, and the compiler can see that precondition assertion when compiling the program, it can generate the appropriate contract checks around every call through \tcode{fp}, such as the one in the last statement of the code above.

The major advantage of this specification strategy over the other two is that adding function contract assertions to a function pointer does not affect the ABI, and is thus fully backwards-compatible with pre-Contracts code, both on the source code level and on the compiled binary level.

However, this specification strategy also has fundamental limitations, regardless of whether we allow the interface and implementation contracts to differ, or we require them to be the same.

Since the information about the contract is neither part of the type, nor part of the value, it will not propagate through when passing a pointer as an argument to a function, assigning a function to a pointer or a pointer to another pointer, etc. There is also no way for this information to cross TU boundaries. Therefore, if we were to pass the pointer \tcode{fp} to another function, and call it from there, the information that there is a contract assertion would get lost:
\begin{codeblock}
void call(void(*fp)(int), int i) {    // this \tcode{fp} has no precondition assertions
  fp(i);       // no contract to check!
}

void test(int i) {
  void(*fp)(int i) pre (i > 0) = f;   // this \tcode{fp} has a precondition assertion
  fp(i);       // contract \tcode{i > 0} checked
  call(fp, i); // contract \tcode{i > 0} not checked!
}
\end{codeblock}
We could add a precondition assertion to the parameter declaration of \tcode{fp} in \tcode{call}, but that precondition assertion would be completely independent of that of \tcode{fp} in \tcode{test} as these are two different objects (even though they will have both the same type and the same value).

The same thing would happen if we assign the pointer value to another pointer variable and that second pointer variable is not declared with the same precondition assertion:
\begin{codeblock}
void test(int i) {
  void(*fp1)(int i) pre (i > 0) = f;   // \tcode{fp1} has a precondition assertion
  fp1(i);   // contract \tcode{i > 0} checked
  
  void(*fp2)(int i) = fp1;             // \tcode{fp2} has no precondition assertions
  fp2(i);  // no contract to check!
}
\end{codeblock}
It would therefore be very easy to end up in a situation where the user intended to have the contract checked in an indirect call, but that contract check inadvertently disappears, compromising the safety of the code.

The function contract assertions will also never apply to intermediate expressions, meaning that we cannot return a pointer to a function that has function contract assertions associated with it, or use such a return value without assigning it to a variable with the appropriate assertions attached to it.

As a consequence of these limitations, this strategy fails to provide any mechanism to satisfy many real uses cases for such a feature. For example, there is no way to define a \tcode{std::function} that has particular function contract assertions associated with its call operator. There is also no way to have function contract assertions attached to template parameters, which means there is no way to have a collection of pointers with such assertions. These use cases could potentially be supported if function contract assertions were part of the type of a function pointer, but not if they are a property of the pointer object.

If we require that the interface and implementation contracts must always be the same, then these semantics \emph{can} be implemented with making the function contract assertions a property of the pointer object: we can make the information about the function contract assertions propagate to different objects through function calls, assignments, etc. by enforcing that all objects involved in these propagations must have the same sequence of function contract assertions. However, this will suffer from all the limitations of the ``interface and implementation contract must be the same'' approach we already discussed in Section~\ref{subsec:samecontract}.

Regardless of which exact set of semantics we choose to implement by making function contract assertions on pointers to functions a property of the pointer object, such an approach would essentially constitute a limited kind of ``shadow type system'' where the assertions are conceptually part of the pointer's type but not treated as part of the type system proper by the compiler. Until C++17, the \tcode{noexcept} specifier was specified in the same way. It was eventually recognised that this leads to odd holes in the type system that have resulted in a number of core issues, and the \tcode{noexcept} specifier was made part of the type system proper for C++17 (see \cite{P0012R1}). It is likely that function pointer assertions would run into similar problems, and potentially even more severe ones, considering that function pointer assertions are a much richer feature than the \tcode{noexcept} specifier.

\section{Alternative approaches}

Given the fundamental limitations of function contract assertions on pointers to functions, which appear regardless of which design direction or specification strategy we pursue, it might be worth considering alternative approaches. Instead of adding function contract assertions to pointers directly, we could support the desired functionality via a novel feature. Such a feature would  introduce a new kind of entity, distinct from pointers to function and pointers to member function, but equipped with similar functionality --- the ability to indirectly call any function of a given type --- and then add function contract assertions to that new entity.

One such proposal is \cite{P3271R0}, proposing to introduce so-called \emph{function usage types}. Instead of a pointer to function with a sequence of function contract assertions attached to it, we would define a function usage type using novel syntax like:
\begin{codeblock}
int takes_and_returns_positive_numbers(int i) usage 
  pre (i > 0)
  post (r: r > 0);
\end{codeblock}
There is then more novel syntax to attach a usage type to a function, pass it around, call a function through it, etc.

While function usage types elegantly avoid many of the limitations discussed in this paper, they are, by virtue of being a new kind of entity, neither API nor ABI compatible with pre-Contracts code --- just like the specification strategies discussed in Sections~\ref{subsec:maketype} and \ref{subsec:makevalue}, but unlike the specification strategy discussed in Section~\ref{subsec:makeobject}.

If we end up realising indirect calls with interface contracts via a novel feature distinct from pointers to function and pointers to member function, and abandoning the idea of adding function contract assertions to such pointers directly, then proposals such as \cite{P3221R0} and \cite{P3250R0} are no longer relevant. These proposals seek to impose limitations on the specification in \cite{P2900R7} on how function contract assertions interact with function addresses and pointers to functions --- proposing to make it ill-formed to take the address of a function that has function contract assertions, and to make it ill-formed to deduce the type of such a function, respectively --- in an attempt to reserve design space for adding function contact assertions to pointers. If we do not add function contract assertions to pointers directly, no such carve-out of design space is necessary in this area, meaning that the specification in \cite{P2900R7} on how function contract assertions interact with function addresses and pointers to functions is sufficiently future-proof and correct in its current form.

It should be clear that given the limited amount of time remaining before the feature freeze deadline for the upcoming C++26 Standard, any feature as novel and far-reaching as function usage types cannot be considered in the C++26 timeframe, and will have to wait until C++29. If we wish to include a Contracts MVP in C++26 --- something that we believe is crucially important in order to address the current concerns around safety and security in the C++ programming language (see \cite{P3269R0}, \cite{P3276R0}, and \cite{P3297R0}) --- it follows that such a Contracts MVP cannot include functionality that depends on an extension in the function pointer space more generally or function usage types more specifically. This is also true if the Contracts MVP does not make C++26: any such extension would be far-reaching and require significant design and implementation experience before it can be adopted, so in any case the progress of \cite{P2900R7} should not be dependent on such an extension.

\section{Conclusion}

In this paper, we have explored the possibility of adding an extension to the Contracts MVP proposal \cite{P2900R7} that allows placing function contract assertions --- \tcode{pre} and \tcode{post} --- on pointers to functions and pointers to member functions. We have defined the concepts of  \emph{interface contract}, \emph{implementation contract}, and \emph{intermediate contract}, how these concepts apply to indirect function calls through a pointer to function, and how that is to a large degree analogous, but not completely identical to interface, implementation, and intermediate contracts on virtual function calls.

We concluded that for pointers to functions and pointers to member functions, there are different choices for the semantics of these different contracts that any proposal in this space needs to make:
\begin{itemize}
\item Treat interface and implementation contracts as independent, i.e. allow the pointer to have a different sequence of function contract assertions than the function it is pointing to, and different pointers that might point to the same function, to have different such sequences;
\item Alternatively, require interface and implementation contracts to be the same, i.e., enforce that a function and all pointers that could point to it have the same sequence of function contract assertions;
\item As an in-between solution, allow certain conversions between different sequences of function contract assertions, but not others, for example allow to assign the address of a function with function contract assertions to a pointer without such assertions, but not to a pointer with a different sequence of assertions;
\item Decide whether intermediate contracts should be checked.
\end{itemize}
Regardless of which direction we choose, in order to make function contract assertions on pointers actually specifiable and implementable, the information about the function contract assertions that apply to a pointer to function needs to live \emph{somewhere}. There are three possible places where this information can be encoded:
\begin{itemize}
\item In the type of the function,
\item In the pointer value,
\item As a property of the pointer object.
\end{itemize}
We explored all three specification strategies and demonstrated that each option comes with significant limitations and consequences for the C++ language, casting doubts on the viability of any of these options. Any proposal for adding function contract assertions to pointers therefore needs to not only clarify which of these three specification strategies it chose, but also outline a concrete implementation strategy and clarify how it addresses the limitations of the chosen specification strategy that we outlined in this paper.

Alternatively, instead of adding function contract assertions to pointers directly, we can consider supporting the desired functionality via a novel feature such as the \emph{function usage types} proposed in \cite{P3271R0}. Function usage types elegantly avoid many of the limitations that arise from any attempt to add function contract assertions to pointers directly. However, they are also a complex and far-reaching extension, and we would be ill-advised to make the progress of the Contracts MVP \cite{P2900R7} dependent on such an extension.

Ultimately, while the ability to specify the interface contract of an indirect function call with function contract assertions is undoubtedly useful functionality, we can conclude from our exploration of this design space that any attempt to specify a feature that offers this functionality inevitably gives rise to significant complexity. No compelling reason why this functionality should be considered absolutely essential for a Contacts MVP has been presented so far (such a claim is  made in \cite{P3173R0}, but the paper provides no rationale; moreover, it lumps indirect calls through pointers to functions together with virtual functions).

Our recommendation is therefore that SG21 and EWG should not treat this functionality as a requirement for a Contacts MVP, but instead consider it as a post-MVP extension.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%
%\phantom{I really need a pagebreak here!}
%\pagebreak % MANUAL %%%%%%%%%

\section*{Acknowledgements}
Thanks to Joshua Berne, Ville Voutilainen, Peter Bindels, and Oliver Rosten for reviewing a draft of this paper and suggesting improvements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%


% Replace ToC entry for bibliography by custom one
%\addtocontents{toc}{\protect\numberline{}} % Blank line in ToC
\addcontentsline{toc}{section}{\protect\numberline{}Bibliography} %Manual ToC entry
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

