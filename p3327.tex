\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on function pointers}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3327R0 \\
Date: &2024-06-20 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R7} that would allow placing function contract assertions --- \tcode{pre} and \tcode{post} --- directly on pointers to functions and pointers to member functions. We identify two possible choices regarding the basic semantics --- enforcing that the pointer and the function have the same sequence of function contract assertions, or allowing them to be different, meaning that the pointer has its own contract. We then identify three apparent design directions for integrating such a feature into the language --- making the function contract assertions a property of the function type, of the pointer value, or of the pointer object. We analyse all three approaches and highlight the shortcomings of each. We conclude that any design that allows placing function contract assertions directly on pointers to functions and pointers to member functions would necessarily have significant limitations, and that we might be better off specifying the desired functionality as a separate, new language feature, such as the \emph{function usage types} proposed in \cite{P3271R0}, rather than by extending the existing notion of pointers to function and pointers to member functions.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

The current proposal \cite{P2900R7} for adding a Contracts facility to C++ --- the so-called \emph{Contracts MVP proposal} --- does not allow function contract assertions, \tcode{pre} and \tcode{post}, to be attached to a pointer to function or pointer to member function. However, it specifies that when a function is invoked through a pointer to function or pointer to member function, the function contract assertions specified on that function itself are still evaluated as normal.

It has been suggested in \cite{P3173R0} that ``a Contracts facility that fails to adequately support efficient use with [...] pointer to functions is woefully inadequate and unready for prime use'', however the paper fails to provide even a sketch of a specification of how such support of pointers to functions --- beyond the current specification in the Contracts MVP --- could actually work.

It has been further suggested in the wake of the discussion around how we could add support for function contract assertions on \emph{virtual functions} (see \cite{P3097R0} and \cite{P3165R0}) that the separation of \tcode{pre} and \tcode{post} on a virtual function into \emph{interface contracts} and \emph{implementation contracts} is isomorphic to the situation when a function is called through a pointer, where \tcode{pre} and \tcode{post} on the pointer is the interface contract and \tcode{pre} and \tcode{post} on the function itself is the implementation contract. It has been further suggested that the syntax and semantics of \tcode{pre} and \tcode{post} on virtual functions should consider function pointers and that the two features should be made consistent with each other. However, again it has not been demonstrated as part of the discussion whether \tcode{pre} and \tcode{post} on pointers to functions could even be made to work, and if so, how.

To inform these ongoing discussions, the present paper provides an exploration of the available design space for placing \tcode{pre} and \tcode{post} on pointers to functions and pointers to member functions. Our exploration focuses on pointers to functions, however all aspects of this exploration apply equally to pointers to member functions.

We begin our exploration with considering the semantics --- what does it \emph{mean} when a function pointer has function contract assertions, and when would these assertions be evaluated? We then consider how these function contract assertions would be integrated into the language, for which there are three apparent options --- making them a property of the function type, of the pointer value, or of the pointer object. We deliberately do not explore the \emph{syntactic} space --- how could we \emph{spell} function contract assertions on a function pointer? --- in much detail in this paper as we consider the syntax secondary to the semantic and conceptual concerns. 

Note that none of these ideas are novel. Support for contract assertions on function pointers has been considered multiple times in past proposals for a C++ Contracts facility. Each time, the idea for providing such support was eventually dropped from the proposal. In the following discussion, we will provide references to these past proposals where appropriate.

\section{Possible semantics}
Consider a function that has function contract assertions (\tcode{pre} and \tcode{post}):
\begin{codeblock}
int f(int i)
  pre (i % 2 == 0)
  post (r: r % 2 == 0);
\end{codeblock}
Now let us assume that we can define a pointer to function \tcode{fp} compatible with \tcode{f}, and that we can specify function contract assertions that apply to \tcode{fp} and not to \tcode{f} (ignoring, for now, the question whether the syntax we use below would actually work with the C++ grammar):
\begin{codeblock}
int (*fp)(int i) 
  pre (i > 0) 
  post (r: r != 0);
\end{codeblock}
Now, what should happen when we initialise \tcode{fp} with the address of \tcode{f}, or assign the address of \tcode{f} to \tcode{fp}, and then call \tcode{f} through \tcode{fp}?
\begin{codeblock}  
void test(int i) {
  fp = f;    
  fp(i);
}
\end{codeblock}
\subsection{Interface and implementation contracts}

In the following discussion, we will call the contract of the pointer \tcode{fp} to be the \emph{interface contract}, and the contract on the function \tcode{f} to be the \emph{implementation contract}. This separation in interface and implementation contract is conceptually the same as for any other type of indirect function call, notably for virtual function calls.

Note that for any indirect function call, we define interface and implementation contract in terms of where in the code that contract is visible, not in terms of where the actual checks will be laid down when generating the binary (caller-side or callee-side); we consider the latter to be merely an implementation detail.

An \emph{interface contract} is a contract known at the call site of the function in question (which might be an indirect call). For virtual functions, an interface contract is checked when that virtual function is the statically called function in a virtual function call; for function pointers, an interface contract is checked when a function is called through that pointer.

An \emph{implementation contract} is a contract known to the definition of the function that is being called, and is checked on all invocations that execute that function's body, regardless of how that invocation happens. For virtual functions, an implementation contract is checked when the function is either the final overrider in a virtual function call, or when is called via a qualified, non-virtual call (directly or indirectly); for function pointers an implementation contract is checked whenever that function is called, regardless of whether that call happens directly or through a pointer, and through which pointer it happens.

For plain, direct function calls, the interface and implementation contracts are always the same contract. However, for indirect calls, such as the call to the function \tcode{f} through the pointer \tcode{fp} above, there is a fundamental choice between two possibilities. The first possibility is to enforce that the interface contract and the implementation contract are also the same contract, as for direct calls. This would mean that the above code is incorrect as the contracts do not match, and should be specified as ill-formed (or perhaps, somewhat less plausibly, as undefined behaviour or erroneous behaviour). The second possibility is that we allow the interface contract and the implementation contract to be \emph{different} contracts. This would mean that the above code is correct, and we need to specify exactly how it should behave.

\subsection{Pointer must have the same contract as the function}
\label{subsec:same}

If we do not wish to allow the interface contract (on the pointer) and the implementation contract (on the function) to be different from each other, we can enforce them to be the same. What this gives us is a mechanism to enable caller-side checking of the precondition and postcondition assertions declared on the function in cases where this would not be possible otherwise\footnote{TO DO which cases are these? Do we have an example?}.

However, this direction restricts the ways in which functions with contract assertions and pointers can be used together. Notably, it would be impossible to declare a pointer to function that has its own sequence of function contract assertions, different from that on the function, and to be checked \emph{in addition} to that of the function, precluding some use cases.

Additionally, this direction makes it harder to write code that compiles since the user is now required to repeat the contract assertions in a lot more places, that is, unless we allow the sequence of function contract assertions to be omitted from the pointer when assigning to it. But such allowance would open up a lot of questions on how exactly it would work: would the function contract assertions still be there implicitly? Or not --- meaning that the interface and implementation contracts are no longer the same as the former is now empty? How would such dropping of contracts occur --- via some kind of implicit or explicit conversion? Could that lead to contract checks being dropped accidentally, potentially introducing an unintended safety risk?

\cite{N4415}, \cite{P0287R0}, and \cite{P0380R0} all allowed function contract assertions to be placed directly on pointers to function, and proposed that assigning a function to such a pointer, or assigning the value of a pointer to function to another such pointer, is ill-formed unless the function contract assertions on both entities match. The motivation at the time was not to enable caller-side checking, but to guarantee that when a function is called through a pointer, its function contract assertions are still checked.

However, in the later revision \cite{P0380R1} it was realised that there is a much more effective way to achieve this, without placing undue burden on the user: we can simply specify that when a function is called through a pointer, its own function contract assertions are still evaluated as if it was called directly. This is the specification that we still have in the Contracts MVP \cite{P2900R7}.

\subsection{Pointer can have contract different from the function}

The other possible choice of semantics is to allow the interface contract and the implementation contract to be different, independent contracts; the corresponding sequence of function contract assertions would be checked separately. The only order of evaluation for these contract assertions on an indirect call that seems to make sense is:
\begin{enumerate}
\item Evaluate the interface precondition assertions,
\item Evaluate the implementation precondition assertions,
\item Execute the body of the function,
\item Evaluate the implementation postcondition assertions,
\item Evaluate the interface postcondition assertions.
\end{enumerate}
While these semantics seem useful, the question remains whether there is actually any possible way to specify and implement a feature that enables such semantics. Unfortunately, if the interface is a pointer to function or a pointer to member function, it is not straightforward at all how this could be achieved. We explore the possible strategies in the following section.

\section{Possible design strategies}

In order to be able to evaluate the contract assertions attached to a pointer to function whenever any function is called through that pointer, information about these contract assertions has to be encoded somewhere in the program. There are three potential places where this information can be stored --- in the type system, in the value representation, or in the object model. In other words, the contract assertions attached to the pointer can be a property of the function type, of the pointer value, or of the pointer object. Choosing any of these three strategies has wide-reaching consequences which we will discuss below.

\subsection{Make \tcode{pre} and \tcode{post} a part of the type system}

If the function contract assertions that apply to a pointer to function are part of the function type, this means that two pointers that have a different sequence of function contract assertions would be of different type, even if they are otherwise the same (again, ignoring for the purposes of this discussion whether the below syntax would actually work):
\begin{codeblock}
void(*fp1)(int i) pre (i > 0);
void(*fp2)(int i) pre (i != 0);
static_assert(std::is_same_v<decltype(fp1), decltype(fp2)>);  // must be \tcode{false}
\end{codeblock}
This immediately raises questions about how these new types should interact. Should these two pointer types be implicitly or explicitly convertible to each other? Should they be convertible to a pointer type \emph{without} function contract assertions or vice versa? But the problem goes much deeper than that.

Any attempt to make contract assertions part of the type system would have to do so consistently --- meaning that regardless of the existence of pointers to functions, the types of \emph{functions} with a different sequence of function contract assertions would have to be different, too:

\begin{codeblock}
void f1(int i) pre (i > 0);
void f2(int i) pre (i != 0);
static_assert(std::is_same_v<decltype(f1), decltype(f2)>);  // must be \tcode{false}
\end{codeblock}
There are numerous problems with such an approach. First of all, it would violate an important design principle from \cite{P2900R7} that has been put in place to ensure seamless adoption of Contracts: if we add function contract assertions to the declaration of a pre-existing function that does not have such assertions, and the new declaration compiles correctly, then all \emph{correct} uses of that function should also still compile, and should have the same compile-time semantics and runtime behaviour as they had before, except that the new contract assertions are now being evaluated.

Another aspect of this is what \tcode{operator \&} will do and how that will interact with type deduction. If we were to ever have \tcode{operator \&} changed to return ``pointer to function with that function's contract assertions'', this would break code like the following:
\begin{codeblock}
void f1() post (r: r > 0);
void f2() post (r: r < 0);

void x() {
  auto* f = &f2;   // pointer with assertion \tcode{post (r: r > 0)}
  if (rand()) {
    f = &f1;  // assigning to a function with a different, incompatible postcondition
  }
  f();  // violation if branch was taken! Certainly not the intent of the original code.
}
\end{codeblock}
But the most severe consequence of making the function contract assertions a part of the type system would be that this would necessarily lead to an explosion of types. In general, any two functions that are supposed to do different things will have different contracts --- because if they had the same preconditions and postconditions, they would, in most cases, be doing the same thing and therefore they should be the same function. The consequence is that practically every function that has function contract assertions will have its own unique type. Any template that takes a function type as a template argument --- consider \tcode{std::sort} or \tcode{std::map} --- would have a separate instantiation for each function provided, leading to significant code bloat that many users might find unacceptable. Making \tcode{noexcept} a part of the type system has --- in the worst case --- doubled the amount of template instantiations; this would be much worse.

Further, the compiler would have to do additional work to determine whether two function types are the same, which means that the sequence of function contract assertions must become a part of the name mangling. This sort of name mangling would also have to happen whenever we use a function type with function contract assertions as a template parameter. This means that function contract assertions must become an explicit part of the ABI --- another complication with wide-ranging consequences that \cite{P2900R7} explicitly seeks to avoid.

Finally, the question arises whether making function contract assertions a part of the function's type would mean that you could \emph{overload} on different function contract assertions., and if so, how the overload resolution would work in this case:
\begin{codeblock}
void f(void (*)(int x) pre(x == 0));  // Overload 1
void f(void (*)(int x) pre(x > 0));   // Overload 2

void r(int x) pre(x == 0);
void s(int x) pre(x > 0);
void t(int x);
void u(int x) pre(x == 0) pre(x == 0);
void u(const int x) pre(x == 0) post(x == 0);

f(&r);  // which f overload is called? Overload 1 seems likely
f(&s);  // which f overload is called? Overload 2 seems likely
f(&t);  f(&u);  f(&v); // now what?
\end{codeblock}
We could also consider making declaring two functions with the same name and signature but different function contract assertions be ill-formed, as it is the case today for two functions that only differ in whether they are \tcode{noexcept(true)} or \tcode{noexcept(false)}, to avoid contract assertions becoming part of overload resolution, but that would again limit the use cases that such a feature could satisfy.

Ultimately, it seems that for all of the above reasons making function contract assertions an explicit part of the type system is not a viable strategy. This has been realised as early as in \cite{N4110} --- an exploration of the Contracts design space published in 2014 that mentioned many of the thoughts covered above --- and reiterated in \cite{N4415}, \cite{P0246R0}, \cite{P0247R0}, \cite{P0287R0}, \cite{P0380R1}, and \cite{P0542R5}.

\subsection{Encode \tcode{pre} and \tcode{post} in the pointer value}

If we cannot encode the function contract assertions applied to a pointer to function in the type of the function or the pointer, the next option is to encode this information in the pointer value. Right off the bat this seems like a less natural choice: the value of a pointer is, in general, a dynamic property that can change at runtime, however we do not consider the function contract assertions of a pointer to function to be such a dynamic property conceptually. Moreover, making the function contract assertions a dynamic property means that their mere existence, regardless of whether we actually want to \emph{check} these assertions, will unavoidably have some overhead, violating another important design principle of \cite{P2900R7}.

Let us take a closer look at how we could make the function contract assertions that apply to a pointer a property of that pointer's value.

One option would be to somehow encode the assertions directly in the object representation of the pointer, but that would inevitably mean that the pointer value will no longer fit into a pointer-sized chunk of memory (8 bytes on a 64-bit system).

Another option would be to generate a thunk that checks the interface contract assertions and then calls the underlying function, and to store the address of that thunk in the pointer. But such a choice would invalidate the assumption that the value of the pointer is the equal to the address of the function it points to. Using such a pointer would also again incur additional overhead, both in binary size and in instructions executed, due to the additional indirection, and more importantly, would involve non-backwards-compatible ABI changes.

Overall, it seems that such an indirection mechanism wrapping a function call with an interface contract check can be specified and implemented, and can be useful, but is so substantially different in its semantics from the current notion of \emph{pointer to function} that it should be a separate feature, and should be spelled differently.

\subsection{Make \tcode{pre} and \tcode{post} a property of the pointer object}

The final possibility for encoding the information needed to specify function contract assertions that apply to a pointer to function is to make these assertions a property of the pointer object. This means that this information is neither part of the type, nor part of the value, but only exists in an ephemeral fashion in the compiler's AST while the program is being compiled. This strategy has been proposed in \cite{P0246R0} and \cite{P0247R0}, but this direction was later abandoned (the papers do not discuss why); nevertheless, it is worth taking another look at this strategy and its consequences.

Consider the following code:

\begin{codeblock}
void f(int i);

void test(int i) {
  void(*fp)(int i) pre (i > 0) = f;
  fp(i);
}
\end{codeblock}
With this strategy, the type of \tcode{fp} would still be just ``pointer to function that takes \tcode{int} and returns \tcode{void}'', and the value of \tcode{fp} would still be just ``address of \tcode{f}'', but because the user added a precondition assertion to the declaration of \tcode{fp}, and the compiler can see that precondition assertion when compiling the program, it can generate the appropriate contract checks around every call through \tcode{fp}, such as the one in the last statement of the code above.

The fundamental limitation of this approach is that since the information about the contract is neither part of the type, nor part of the value, it will not propagate through when passing a pointer as an argument to a function, assigning a function to a pointer or a pointer to another pointer, etc. There is also no way for this information to cross TU boundaries.

If we were to pass the pointer \tcode{fp} to another function, and call it from there, the information that there is a contract assertion would get lost:
\begin{codeblock}
void call(void(*fp)(int), int i) {    // this \tcode{fp} has no precondition assertions
  fp(i);       // no contract to check!
}

void test(int i) {
  void(*fp)(int i) pre (i > 0) = f;   // this \tcode{fp} has a precondition assertion
  fp(i);       // contract \tcode{i > 0} checked
  call(fp, i); // contract \tcode{i > 0} not checked!
}
\end{codeblock}
We could add a precondition assertion to the parameter declaration of \tcode{fp} in \tcode{call}, but that precondition assertion would be completely independent of that of \tcode{fp} in \tcode{test} as these are two different objects (even though they will have both the same type and the same value).

The same thing happens if we assign the pointer value to another pointer variable and that second pointer variable is not declared with the same precondition assertion:
\begin{codeblock}
void test(int i) {
  void(*fp1)(int i) pre (i > 0) = f;   // \tcode{fp1} has a precondition assertion
  fp1(i);   // contract \tcode{i > 0} checked
  
  void(*fp2)(int i) = fp1;             // \tcode{fp2} has no precondition assertions
  fp2(i);  // no contract to check!
}
\end{codeblock}
It would therefore be very easy to end up in a situation where the user intended to have the contract checked in an indirect call, but that contract check inadvertently disappears, compromising the safety of the code.

The function contract assertions will also never apply to intermediate expressions, meaning that we cannot return a pointer to a function that has function contract assertions associated with it, or use such a return value without assigning it to a variable with the appropriate assertions attached to it.

As a consequence of these limitations, this strategy fails to provide any mechanism to satisfy many real uses cases for such a feature. For example, there is no way to define a \tcode{std::function} that has particular function contract assertions associated with its call operator. There is also no way to have function contract assertions attached to template parameters, which means there is no way to have a collection of pointers with such assertions. These use cases could potentially be supported if function contract assertions were part of the type of a function pointer, but not if they are a property of the pointer object.

An alternative to the above approach that \emph{can} be implemented with making the function contract assertions a property of the pointer object would be to make the information about the function contract assertions propagate to different objects through function calls, assignments, etc. by enforcing that all objects involved in these propagations must have the same sequence of function contract assertions. We already discussed this strategy, and its limitations, in section \ref{subsec:same} above.

Regardless of whether such restrictions are in place, making function contract assertions on pointers to functions a property of the pointer object would essentially constitute a limited kind of ``shadow type system'' where the assertions are conceptually part of the pointer's type but not treated as part of the type system proper by the compiler. Until C++17, the \tcode{noexcept} specifier was specified in the same way. It was eventually recognised that this leads to odd holes in the type system that have resulted in a number of core issues, and the \tcode{noexcept} specifier was made part of the type system proper for C++17 (see \cite{P0012R1}). It is likely that function pointer assertions would run into similar problems, and potentially even more severe ones, considering that function pointer assertions are a much richer feature than the \tcode{noexcept} specifier.

\section{Conclusion}

In this paper, we have explored the possibility of adding an extension to the Contracts MVP proposal \cite{P2900R7} that allows placing function contract assertions --- \tcode{pre} and \tcode{post} --- on pointers to functions and pointers to member functions. We have defined the concepts of  \emph{interface contract} and  \emph{implementation contract} and how they apply to an indirect function call through a pointer to function. We concluded that the interface contract (the one on the pointer) and the interface contract (the one on the function) can either be required to be the same, or allowed to be different (and therefore checked separately), with different tradeoffs between these two design directions.

In any case, in order to make function contract assertions on pointers actually specifiable and implementable, the information about the function contract assertions that apply to a pointer to function needs to live \emph{somewhere}. There are three apparent possibilities: we could make these function contract assertions a property of the function type, of the pointer value, or of the pointer object. We explored all three options and demonstrated that each option comes with serious limitations and ramifications for the C++ language, casting doubts on the viability of any of these options.

An indirection mechanism similar to a pointer to function or pointer to member function, which allows to call an arbitrary function of a given type while specifying interface contract assertions that additionally apply to such an indirect call, certainly seems like a useful feature. However, we can conclude from our findings that, rather than realising this functionality by allowing adding function contract assertions to pointers directly, we should consider specifying it as a separate, novel feature, similar to but distinct from pointers to function and pointers to member function, and with a distinct, novel syntax, as this has the potential to avoid the known limitations and support a much wider range of use cases.

One such novel feature, called \emph{function usage types}, is being proposed in \cite{P3271R0}. Our recommendation is that SG21 and EWG should consider \cite{P3271R0}, and encourage more proposals in this space, instead of pursuing the addition of function contract assertions to pointers directly.

It should be clear that given the limited amount of time remaining, any feature as novel and far-reaching as function usage types cannot be considered for the C++26 Standard, and will have to wait until C++29. If we wish to include a Contracts MVP in C++26 --- something that we believe is crucially important in order to address the current concerns around safety and security in the C++ programming language (see \cite{P3269R0}, \cite{P3276R0}, and \cite{P3297R0}) --- it follows that such a Contracts MVP cannot include functionality that depends on an extension in the function pointer space more generally or function usage types more specifically. This is also true if the Contracts MVP does not make C++26: any such extension would be far-reaching and require significant design and implementation experience before it can be adopted, so in any case the progress of \cite{P2900R7} should not be dependent on it. 

Finally, if instead of adding assertions to pointers directly, we wish to realise this functionality via a novel feature, proposals such as \cite{P3221R0} and \cite{P3250R0} are no longer necessary. These proposals seek to impose limitations on the specification in \cite{P2900R7} on how function contract assertions interact with function addresses and pointers to functions --- proposing to make it ill-formed to take the address of a function that has function contract assertions, and to make it ill-formed to deduce the type of such a function, respectively --- in an attempt to reserve design space for adding  contact assertions to pointers. We conclude that no such carve-out of design space is necessary in this area, and that the specification in \cite{P2900R7} on how function contract assertions interact with function addresses and pointers to functions is sufficiently future-proof and correct in its current form.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%
%\phantom{I really need a pagebreak here!}
%\pagebreak % MANUAL %%%%%%%%%

\section*{Acknowledgements}
Thanks to Joshua Berne and Ville Voutilainen for reviewing a draft of this paper and suggesting improvements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%


% Replace ToC entry for bibliography by custom one
%\addtocontents{toc}{\protect\numberline{}} % Blank line in ToC
\addcontentsline{toc}{section}{\protect\numberline{}Bibliography} %Manual ToC entry
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

