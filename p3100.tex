\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

\begin{document}
\title{Contracts, Undefined Behaviour, and Erroneous Behaviour}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio})  
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3100R0 \\
Date: &2024-01-25 \\
Project: & Programming Language C++ \\
Audience: & EWG, SG21, SG23
\end{tabular}

\begin{abstract}
TODO
\end{abstract}

\section{Introduction}
\label{sec:intro}

\subsection{Safety and security in C++}


Improving safety and security is one of the main challenges for the future evolution of the C++ language (\cite{Bastien2023}). According to the definition in \cite{Carruth2023}, safety is characterised by invariants or limits on program behaviour in the face of bugs; safety bugs are bugs where some aspect of program behaviour has no invariants or limits. According to the definition of \cite{Abrahams2023}, a safe operation is one that cannot cause undefined behaviour; a safe language has only safe operations. 

According to these definitions, C++ is not a safe language: both the core language and the C++ standard library allow for a multitude of ways in which a well-formed C++ can exhibit unbounded undefined behaviour, that is, situations in which the C++ standard places no restrictions on the behaviour of the program. Bugs that trigger undefined behaviour cause stability issues and can be exploited by threat actors, thereby causing security vulnerabilities.

Of particular concern is undefined behaviour due to invalid memory accesses, which was found by large companies such as Google and Microsoft to be responsible for $\~ 70$\% of security vulnerabilities (\cite{NSA2022}, \cite{CR2023}). This led various government agencies to start advocating for an industry-wide shift away from C and C++ and towards memory-safe languages such as Rust (\cite{EU2022}, \cite{CISA2023}, \cite{ONCD2024}), triggering a debate about the future of C++.

\subsection{Current approaches}

Various approaches exist to manage undefined behaviour in C++. Some of them are good engineering practices that are not specific to C++, such as practicing code reviews, enforcing coding guidelines such as MISRA or the C++ Core Guidelines, and automated testing targeting different aspects of the code (unit tests, fuzz tests, etc). When applied correctly, these techniques can significantly reduce the amount of undefined behaviour entering production code. In addition, it can be effective to use tooling in order to find instances of undefined behaviour either at compile time (by using static analysis tools such as Coverity, Sonar, PVS-Studio, etc.) or at runtime (by running sanitisers such as ASan and UBSan).

In addition, the ISO C++ committee, as the body owning the specification of the C++ programming language, is in the unique position to be able to evolve this specification to eliminate sources of undefined behaviour \emph{normatively}. Given that undefined behaviour in C++ is fundamentally a runtime property, there are two fundamental ways to approach it: by making certain constructs that would have undefined behaviour at runtime ill-formed (i.e. diagnosing such constructs \emph{statically} at compile time) on the one hand, or by re-specifying the runtime behaviour of such constructs to be well-defined rather than undefined (i.e. handling undefined behaviour \emph{dynamically} at runtime).

\subsection{Runtime handling of undefined behaviour}

In principle, it would be possible to change C++ such that by default, undefined behaviour can no longer occur, because any  potentially unsafe construct would be rejected at compile time. The Rust programming language is a successful proof of concept for this approach. However, doing so would break practically any useful program that exists in C++ today, and is therefore not a realistic prospect \cite{Doumler2023}. For example, in order to statically reject memory bugs, we would need to make any code ill-formed that allows multiple pointers or references to the same object to exist, unless it can be statically proven that all such pointers or references are \tcode{const}. This effectively requires an approach like Rust's borrow checker or Hylo's mutable value semantics, thereby disqualifying any C++ code that returns a non-\tcode{const} reference from a function, uses random access, doubly-linked lists, etc. This might be viable for some \emph{new} code (where potentially unsafe constructs could be limited to \emph{unsafe blocks} like in Rust), but not for \emph{existing} code. 

Therefore, to address safety in C++, we should follow a two-pronged approach. On the one hand, we should aim to make more undefined behaviour diagnosable at compile time, wherever the tradeoffs for doing so are favourable. On the other hand, we also need to accept that some instances of undefined behaviour will remain undiagnosable at compile time for the foreseeable future, and will have to be handled at runtime instead. The aim of this paper is to focus entirely on such runtime handling, while leaving compile-time detection to other ongoing efforts.

\subsection{The role of Contracts}

\cite{P2900R6} proposes to add a Contracts facility to C++. While this proposal is currently only a minimum viable product (MVP) with a limited number of features, it has been explicitly designed with extensibility in mind. This paper proposes one such extension.

It has been stated that such an extensible Contracts facility is a panacea that has the potential to solve the undefined behaviour problem in C++. This is a misconception. Contracts are the wrong tool for making more undefined behaviour diagnosable at compile time. However, for all the undefined behaviour \emph{not} diagnosed at compile time, Contracts provides a comprehensive framework for handling such undefined behaviour at runtime. The key idea is to respecify specific instances of core language undefined behaviour to be a \emph{contract violation}. This allows us to formally speak of incorrect code and to define its behaviour in the C++ Standard, rather than leaving the behaviour undefined. This behaviour can be configured by the user (issue a diagnostic message, terminate the program, ignore the contract violation, etc.) by choosing one of several standard \emph{evaluation semantics}.

Recently, the committee has adopted the proposal (\cite{P2795R5}) into the C++26 working draft, which follows essentially the same motivation. The proposal makes reading an uninitialised variable well-defined by specifying it as \emph{erroneous behaviour}, another term for behaviour that is incorrect, but not undefined. When encountering erroneous behaviour, an implementation is allowed and encouraged to diagnose this error, but is also allowed to ignore the error and treat the read as valid. The paper goes on to say that other instances of undefined behaviour can be respecified to be erroneous behaviour instead.

As we will show in this paper, the semantics provided by erroneous behaviour are essentially a subset of the semantics that the Contracts framework provides. We can therefore entirely subsume erroneous behaviour into contract violation handling. As a result, we get a unified framework for reasoning about and handling runtime undefined behaviour that is more generic and flexible than erroneous behaviour and has several other advantages over the approach of \cite{P2795R5}.

\section{The Contracts MVP}
\subsection{Explicit contract assertions}

The current Contracts MVP \cite{P2900R6} proposes to add \emph{contract assertions}, i.e. syntactic constructs such as \tcode{pre(x)}, \tcode{post(x)}, and \tcode{contract_assert(x)}, where \tcode{x} is a boolean expression, to express conditions that are expected to be true in a correct program. These contract assertions can be either ignored or checked. When checked, the predicate \tcode{x} is evaluated; if it evaluates to \tcode{false}, a contract violation has been detected. In general, a contract violation means that the program is \emph{incorrect} (i.e. has a bug), but the behaviour of the program is nevertheless well-defined at this point. 

What exactly happens after a contract violation has been detected is determined by the chosen \emph{contract evaluation semantic}. \cite{P2900R6} proposes four such semantics: \tcode{ignore}, \tcode{observe}, \tcode{enforce}, and \tcode{quick_enforce}. The first one is an \emph{unchecked} semantic, whereas the others are \emph{checked} semantics; the latter two are \emph{enforcing} semantics, i.e. semantics that will not allow the code to continue execution past a contract violation. This prevents the program from executing buggy code that might cause undefined behaviour, for example:
\begin{codeblock}
T& vector::operator[](size_t index)
  pre (index < size()) {  // user-defined contract assertion
  return data[index];     // cannot get here if using an enforcing semantic!
}

void test() {
  vector<int> v;
  return v[666];  // program does not have UB if using an enforcing semantic!
}
\end{codeblock}
In the remainder of this paper, we will call these \cite{P2900R6} contract assertions \emph{explicit contract assertions} as they have been explicitly added by the user.

\subsection{Evaluation semantics}

Describe the four here... move some of the stuff from the previous subsection (including the second half of the code example) down here

\section{The proposal}

\subsection{Implicit contract assertions}

The core idea of this proposal is that we can apply the evaluation semantics proposed in \cite{P2900R6} not just to explicit contract assertions, but also to core language constructs that today have undefined behaviour. Consider, for example, signed integer addition. When adding two \tcode{int}s \tcode{a} and \tcode{b}, instead of saying that the behaviour is undefined if the result of the addition is not representable by \tcode{int}, we can say that signed integer addition has an \emph{implicit precondition assertion} that the addition will not overflow. In other words, if we notionally consider signed integer addition to be a built-in \tcode{operator+(int, int)}, this built-in operator will behave as if it was declared with the following precondition assertion:
\begin{codeblock}
int operator+(int a, int b)
  pre ((b >= 0 && a <= INT_MAX - b) || (b < 0 && a >= INT_MIN - b));
\end{codeblock}
We call this precondition assertion \emph{implicit} because it has not been added to the program in the form of an explicit, \cite{P2900R6} style precondition assertion, but is instead implicitly generated by the compiler.

In the same  replace any occurrence of ``for operation $X$, if $Y$ is false, the behaviour is undefined'' with ``operation $X$ has the implicit precondition that $Y$ is true''.

\subsection{Well-defined, safe fallback behaviour}

So far, we have merely re-specified undefined behaviour to 

We can distinguish

In addition, to make this operation \emph{safe}, we need to specify some kind of well-defined behaviour for the error case (we call this the \emph{safe fallback behaviour}). For signed integer addition, we can specify that the result of the implicit addition operator will be some well-defined number. We could specify the value of this number, for example, by specifying that signed integer overflow wraps or saturates, but it is entirely sufficient to say that it will be an unspecified number. Using this number in a calculation will most likely be incorrect (i.e. a bug), but it will no longer be undefined behaviour.


\subsection{Non-ignorable implicit contract assertions}

\subsection{Adding the \tcode{assume} semantic}

Like explicit precondition assertions, implicit precondition assertions are evaluated with one of the following \emph{evaluation semantics}, listed from most ``safe'' to least ``safe'':
\begin{itemize}
\item \tcode{quick_enforce}: evaluate the contract predicate; if a contract violation occurs, immediately terminate the program.
\item \tcode{enforce}: evaluate the contract predicate; if a contract violation occurs, call the contract-violation handler. When the contract-violation handler returns, terminate the program.
\item \tcode{observe}: evaluate the contract predicate; if a contract violation occurs, call the contract-violation handler. When the contract-violation handler returns, continue execution.
\item \tcode{ignore}: do not evaluate the contract predicate.
\item \tcode{assume}: do not evaluate the contract predicate; if it would not evaluate to \tcode{true}, the behaviour is undefined (thus, an implementation is allowed to optimise the program based on the assumption that the predicate is \tcode{true}).
\end{itemize}
Note that \cite{P2900R6} only proposes the first four evaluation semantics, but not \tcode{assume}. In this paper, we propose to add \tcode{assume} to the list of possible evaluation semantics. As we will see, \tcode{assume} is crucially important for \emph{implicit} contract assertions, as it allows us to keep full compatibility with C++23 and earlier if the user wishes to do so.

We follow the model in \cite{P2900R6} that the selection of evaluation semantics is entirely \emph{implementation-defined}, i.e. any implementation could choose any of these semantics for any operation and still be conforming. That is, no implementation is required to check any implicit contract assertions; however, if it chooses to do so, we can now reason about the behaviour within the scope of the C++ Standard, and no longer have to treat it as undefined and therefore unsafe.

Using again the signed integer overflow example, we can see how the different possible evaluation semantics map to different existing implementation strategies:
\begin{itemize}
\item The GCC compiler option \tcode{-ftrapv}, which aborts the program on signed integer overflow, is a conforming implementation of the \tcode{quick_enforce} evaluation semantic;
\item A sanitiser which detects signed integer overflow and prints a diagnostic is a conforming implementation of the \tcode{enforce} evaluation semantic;
\item The GCC compiler option \tcode{-fwrapv}, which implements signed integer addition using wrap around using twos-complement representation, is a conforming implementation of the \tcode{ignore} evaluation semantic;
\item Today's default behaviour for optimised builds, which is to assume that signed integer addition can never overflow, and optimise based on this assumption, is a conforming implementation of the \tcode{assume} evaluation semantic.
\end{itemize}

We can construct the same mapping for any kind of undefined behaviour for which we can define a safe fallback behaviour. For example, undefined behaviour due to reading an indeterminate value can be respecified such that reading a value has an implicit precondition that the value is not indeterminate; if the value is indeterminate, the result will be some unspecified value (but no longer undefined behaviour). A conforming C++ implementation can apply any of the five evaluation semantics to this implicit precondition: \tcode{enforce} gives a diagnostic followed by termination, \tcode{ignore} simply reads some unspecified value (initialising all values to \tcode{0} would be a conforming implementation of this semantic), while \tcode{assume} matches the default in C++23 and before, where reading such a value is undefined behaviour (and the compiler can therefore optimise on the assumption that it never happens).


\subsection{Undefined behaviour with no fallback}

Dereferencing a pointer, out-of-bounds access into an array.

\subsection{Contract-violation handling API}

df

\section{Discussion}

\subsection{Erroneous behaviour}

This proposal entirely supersedes the concept of \emph{erroneous behaviour} as proposed in \cite{P2795R5}.

Note that when \cite{P2795R5} talks about a program that \emph{erroneously} does $X$, this is exactly equivalent to saying that $X$ happens after a contract violation has been detected.

Write about options,  fallbackj

Difference: fallback does not require syntax. This is important for assume and backwards compat. complexity of the lanugae.

Table


\subsection{Safety vs. performance}

sdf

%\section*{Document history}

%\begin{itemize}
%\item \textbf{R0}, 2023-03-08: Initial version.
%\item \textbf{R1}, 20XX-XX-XX: ??
%\end{itemize}

%\section*{Acknowledgements}

%nothing here yet

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{ref}

\end{document}
