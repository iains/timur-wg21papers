\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on coroutines}
\author{
% TODO: commented-out authors have not yet confirmed whether they're willing to co-author
%Andrzej Krzemie\' nski \small(\href{mailto:akrzemi@gmail.com}{akrzemi@gmail.com}) \\
%Iain Sandoe \small(\href{mailto:iain@sandoe.co.uk}{iain@sandoe.co.uk}) \\
%Gor Nishanov \small(\href{mailto:gorn@microsoft.com}{gorn@microsoft.com}) \\
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Peter Bindels \small(\href{mailto:dascandy@gmail.com}{dascandy@gmail.com}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) 
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3327R0 \\
Date: &2024-09-11 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R8} that allows placing function contract assertions --- \tcode{pre} and 
\tcode{post} --- on coroutines. We analyse the available solution space, formulate our design goals, and propose the solution that best satisfies those design goals, taking into account the fundamental design principles behind both Contracts and coroutines.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Motivation}
\label{intro}

The current Contracts MVP proposal \cite{P2900R8} makes it ill-formed for a function \tcode{f} to have function contract assertions --- \tcode{pre} and \tcode{post} --- if \tcode{f} is a coroutine; it merely allows \tcode{contract_assert} inside the body of \tcode{f}. This is in many ways unfortunate. As \cite{P3173R0} points out, coroutines are a foundational facility of modern C++ and thus a Contracts proposal should adequately address uses of contract assertions in combination with coroutines.

It has been argued that coroutines are complex and that therefore, their interaction with Contracts is not straightforward and supporting \tcode{pre} and \tcode{post} on coroutines should be delayed post-MVP. The goal of this paper is to resolve the confusion. Hampering the ability to apply \tcode{pre} and \tcode{post} to coroutines does not achieve that; we should not give users more reasons to avoid coroutines.

The fundamental design principle of coroutines is that whether \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or at a call to \tcode{f}. This design principle should and can be applied to Contracts as well. If a Contracts proposal introduces new ways in which coroutines are different from other functions --- such as disallowing the usage of \tcode{pre} and \tcode{post} on them --- then such a design is in contradiction with how coroutines are designed and specified in C++ today. Ideally, coroutines should work exactly the same as other functions with respect to Contracts.

In a way, this is the only plausible design, and as such, the current restriction in \cite{P2900R8} that \tcode{pre} and \tcode{post} cannot be applied to a coroutine seems arbitrary. Any function \tcode{f} that is a coroutine where one would like to apply \tcode{pre} and \tcode{post} can be indirected through a single other function \tcode{g} which is not a coroutine, and any \tcode{pre} and \tcode{post} the user wishes to apply to \tcode{f} can instead be applied to \tcode{g}:
\begin{codeblock}
auto g()  // not a coroutine
  pre (/*...*/) 
  post (r: /*...*/) 
{ 
  return f();  // a coroutine
} 
\end{codeblock}
With such an indirection, the contracts applied to the wrapper function \tcode{g} will necessarily do exactly what they would be doing on \tcode{f}. This observation is key to the question how we should specify \tcode{pre} and \tcode{post} on coroutines directly. 

The only exception to the above is that in a coroutine, function parameters may have been moved from by the implementation, even if they are declared \tcode{const}, which cannot happen in a non-coroutine function. Therefore, the question arises whether \tcode{post} on a coroutine should see the original parameter objects (which may have moved-from values), the parameter copies created by the implementation for the coroutine (which the original values have been moved to), or something else. In the non-coroutine wrapper \tcode{g}, this question cannot arise, as only the original parameter objects are visible to \tcode{g}, and the choice of copying or moving parameters that might be used in \tcode{post} is up to the user and not the compiler. We will discuss this issue in more detail and propose an adequate solution below.

\section{Prior work}

The C++2a Contracts proposal \cite{P0542R5} did not take coroutines into account because they were not yet part of the C++ Standard at the time.

Post-C++20, SG21 decided to not support \tcode{pre} and \tcode{post} in the Contracts MVP proposal ``until we have a more complete picture of what we intend to provide'' (see \cite{P2932R3}).

Later, \cite{P2957R0} proposed to add support for \tcode{pre} and \tcode{post} on coroutines, with semantics analogous to non-coroutine functions (see Section \ref{impldetail}). This paper was seen by SG21 in Kona (November 2022) and rejected due to uncertainty about the semantics of referring to parameters in \tcode{post}, which might be moved into the coroutine frame and become moved-from values even if the parameter is \tcode{const} (see Section \ref{paramsinpost}).

In \cite{P3173R0}, seen by EWG in Tokyo (February 2023), support for coroutines was named by a major compiler vendor as one of the criteria for the viability of a Contracts MVP proposal.

Subsequently, it was proposed in \cite{P2957R1} and in \cite{P3251R0} that we should allow \tcode{pre} on coroutines, but not \tcode{post}, to avoid the known problem regarding moved-from parameters in \tcode{post}. Neither paper has yet been seen by SG21 at the time of writing.

This paper incorporates some material from \cite{P3251R0}. It also builds on \cite{P2957R1} and has significant overlap with it, but approaches the problem with a design goal-driven approach and seeks to provide a more exhaustive analysis of the available solution space. 
% TODO: merge P2957R1 into this paper if the authors agree, and rephrase this paragraph

\section{Discussion}

\subsection{Coroutine-ness is an implementation detail}
\label{impldetail}

As we established in Section \ref{intro}, the fundamental design principle behind C++ coroutines, which any Contracts proposal must respect, is that the coroutine-ness of a function \tcode{f} is an implementation detail.

For example, assuming that \tcode{generator<T>} is a conforming promise type (\href{https://eel.is/c++draft/dcl.fct.def.coroutine}{[dcl.fct.def.coroutine]}), given a function declaration 
\begin{codeblock}
generator<int> iota(int n); 
\end{codeblock}
it is impossible to tell if \tcode{iota} is a coroutine implemented as follows:
\begin{codeblock}
generator<int> iota(int n) {
  while (true)
    co_yield n++;
}
\end{codeblock}
or whether \tcode{iota} is a non-coroutine function wrapping a coroutine \tcode{iota_coro_impl} as follows:
\begin{codeblock}
generator<int> iota(int n) {
  return iota_coro_impl(n);
}
\end{codeblock}
or whether no coroutines are involved at all, and \tcode{iota} is a non-coroutine function that manually initialises an object of type \tcode{generator<int>} and returns it, without using any of the C++ coroutine machinery. In all of the above cases, \tcode{pre} and \tcode{post} on the function declaration of \tcode{iota} should mean the same thing and have the same behaviour.

\subsection{The interface of a coroutine}

The full interface of a coroutine consists of two parts. First, there is the coroutine function interface, which is exposed to the caller through the function declaration. This interface covers the initial function call and the returned state at the point of first suspension. From the caller's perspective, the function call behaves like a factory function that creates a coroutine return object; current implementations call this factory function a \emph{ramp function}.

In addition, the coroutine has an extended interface, which covers the additional resume and suspend points of the coroutine and is implemented in the coroutine body and the promise type.  Through this extended interface, one can repeatedly yield values via \tcode{co_yield}, await such values via \tcode{co_await}, and return a final value via \tcode{co_return}.

From the design principle that coroutine-ness is an implementation detail it follows directly that the function contract assertions --- \tcode{pre} and \tcode{post} --- on a coroutine declaration must specify the contract of the ramp function. One of the design principles of the Contracts MVP (\cite{P2900R8}, Section 3.1, Design Principle 11) is that \tcode{pre} and \tcode{post} serve both caller and callee. In this case, the callee is the compiler-generated body of the ramp function (see [\href{https://eel.is/c++draft/dcl.fct.def.coroutine#5}{dcl.fct.def.coroutine.5}]): \tcode{pre} on a coroutine is an assertion on the parameters passed into the ramp function when it is called, \emph{before} the coroutine frame is constructed, and the state of the program at that point; \tcode{post} on a coroutine is an assertion on the object that the ramp function returns to the caller at the point of first suspension, and the state of the program at that point.

Importantly, the callee of \tcode{pre} and \tcode{post} on the coroutine declaration is \emph{not} the coroutine body --- the function body that the user wrote --- and \tcode{pre} and \tcode{post} on the coroutine declaration do not assert anything directly related to that body. The coroutine body may run on another thread, resume long after the postconditions that apply to the declaration are checked, or even finish before then\footnote{A coroutine frame can be destroyed on initial suspend, which happens before \tcode{post} is checked.}. The disconnect between function declaration and function body may seem strange and unintuitive to users not familiar with coroutines; but it is part of their design and is not changed or made any worse by adding contract assertions to the declaration.

Additionally, one might want to add contract assertions to the extended coroutine interface to specify precondition and postcondition assertions on the values yielded from the coroutine and the state of the program at its suspend and resume points. However, since it is not visible on the function declaration whether a function is a coroutine, contract assertions on this extended interface cannot be specified on the function declaration, at least not without modifying the basic design of coroutines (which we do not contemplate in this paper). We can, of course, consider a novel language feature to express such assertions, as a hypothetical post-MVP extension to Contracts. But many use cases for such assertions can already be accomplished with the existing functionality in \cite{P2900R8} by using \tcode{contract_assert} inside the coroutine body or, for contracts that hold for any entity that uses a given promise type, by applying \tcode{pre} and/or \tcode{post} to the various callback functions in that promise type. This latter approach is described in more detail in \cite{P3251R0}. For the remainder of this paper, we focus solely on the coroutine function interface.

\subsection{Point of evaluation of \tcode{pre} and \tcode{post}}

As pointed out in \cite{P2957R1}, the way in which the point of evaluation of \tcode{pre} and \tcode{post} is defined in \cite{P2900R8} needs some slight clarifications for coroutines, however, according to the mental model described in the previous section, this does not conceptually change the point of evaluation itself or compromise the equivalence between coroutines and non-coroutine functions.

\cite{P2900R8} specifies that the precondition assertions are evaluated ``immediately after function parameters are initialised and before entering the function body''. For a coroutine, by ``function body'', we do \emph{not} mean the coroutine body that the user wrote, but the body of the ramp function that the compiler generated. Therefore, the precondition assertions of a coroutine are evaluated \emph{before} any of the coroutine-specific events that happen in the ramp function, such as creating a copy of the parameters, allocating the coroutine frame, initialising the promise object, etc.

\cite{P2900R8} further specifies that the postcondition assertions are evaluated ``after the return value has been initialised and local automatic variables have been destroyed but prior to the destruction of function parameters''. Again, for a coroutine, this specification should be applied to the body of the ramp function and not the coroutine body, meaning that the ``return value'' is that of the ramp function (and not any values yielded by the coroutine), and its type is the declared return type of the coroutine; and likewise, the ``local variables'' are those created by the ramp function (and \emph{not} the local variables in the coroutine body).

\subsection{The problem: referring to parameters in \tcode{post}}
\label{paramsinpost}

Unfortunately, there is one difference between coroutines and non-coroutine functions that is unobservable caller-side today, but would be made observable in the predicate of a \tcode{post} that applies to a coroutine. This difference is what makes a proposal to allow function contract assertions on coroutines non-trivial, and has prevented the adoption of such a feature until now.

When the ramp function is invoked, after initialising the function parameters (and checking the precondition assertions, if we allow this), a copy of each parameter is created in the coroutine frame, and the value of each parameter is moved into that copy ([\href{https://eel.is/c++draft/dcl.fct.def.coroutine#13}{dcl.fct.def.coroutine.13}]), leaving the original parameter object in a moved-from state. This is necessary to make the parameters accessible in the coroutine frame, whose lifetime can extend far beyond the ramp function returning. Notably, this moving-from a parameter happens even if that parameter is \tcode{const}: the ramp function removes the top-level \tcode{const} from the parameter, as if by performing a \tcode{const_cast}, and then modifies that parameter by using it to move-construct the copy. In a non-coroutine function, this cannot happen, as attempting to move from a \tcode{const} object would be undefined behaviour. However, in a coroutine, the parameter object is not considered \tcode{const} in the ramp function even if declared as such ([\href{https://eel.is/c++draft/dcl.fct.def.coroutine#note-2}{dcl.fct.def.coroutine.13 Note 2}]).

This specification seems strange, but does not cause issues in C++ today because the moved-from parameter values in a coroutine are not exposed or made accessible to the user in any way. However, this would change if we allowed referring to a function parameter in \tcode{post}. Since \tcode{post} will be evaluated after the move-from has happened, an \emph{id-expression} that refers to a parameter in the predicate of \tcode{post} would now refer to a moved-from value, even if the parameter object is \tcode{const}, making an implementation detail of C++ coroutines observable to the user in a potentially unexpected and undesirable way.

\subsection{The solution space}
\label{solutions}

There are different possible solutions to the moved-from parameter problem. In order from least to most consistent with the principle that coroutine-ness should be an implementation detail, these are:
\begin{enumerate}
\item Do not allow \tcode{pre} or \tcode{post} on coroutines at all (status quo in \cite{P2900R8});
\item Allow \tcode{pre} on coroutines, but not \tcode{post} (first proposed in \cite{P2957R1});
\item Allow \tcode{post} on coroutines, but do not allow referring to parameters (first mentioned in \cite{P2957R1} as an alternative);
\item Allow referring to parameters in \tcode{post}; an \emph{id-expression} naming a parameter refers to the copy made for the coroutine frame;
\item Allow referring to parameters in \tcode{post}; an \emph{id-expression} naming a parameter refers to the original object, and:
\begin{enumerate}[label=\alph*.,ref=\theenumi\alph*]
        \item copy-construct instead of move-construct the copy made for the coroutine frame;
        \item make it ill-formed to refer to a parameter whose type has a non-trivial move constructor (i.e., the parameter can have a moved-from value);
        \item do not add any special provision, meaning that the \emph{id-expression} may refer to a moved-from value, even if the parameter type is \tcode{const} (first proposed in \cite{P2957R0}).
\end{enumerate}
\end{enumerate}

If our only concern was to optimise for the design goal that coroutine-ness is an implementation detail, it seems that 5c would be the correct solution. However, in order to make the proposed Contracts facility as user-friendly as possible, we might wish to consider other design goals as well, making the choice of the correct solution a non-trivial task. We discuss these other design goals in the following section.

\section{Design goals}

\subsection{The Contracts Prime Directive}

The most fundamendal design principle of the Contracts MVP, the so-called Contracts Prime Directive (\cite{P2900R8}, Section 3.1, Principle 1) states that adding \tcode{pre} or \tcode{post} to an existing program should not alter the correctness of that program, as this would undermine the purpose of contract assertions --- instead of checking the correctness of the program the user wrote, they would check the correctness of some other program, potentially leading to so-called ``Heisenbugs'' as well as other problems.

A corollary of this fundamental principle is that adding \tcode{pre} or \tcode{post} to an existing program should not change the compile-time or run-time semantics of that program (see \cite{P2900R8}, Section 3.1, Principles 2 and 3).

Solution 4 violates this principle. While making parameters in \tcode{post} refer to the object in the coroutine frame seems implementable, it will require changes to the semantics of the coroutine, such as extending its lifetime (otherwise, the coroutine frame may be destroyed during initial suspend, i.e. before \tcode{post} is checked, and the parameter object along with it). Without making changes to the coroutine semantics, there would be no point where the parameter copies and the return value necessarily exist at the same time, and therefore no point at which \tcode{post} could be checked.

Solution 5a violates this principle as well, as adding \tcode{post} to a coroutine would incur an additional copy, even if the \emph{ignore} semantic is used and predicate is never checked. For the same reason, we made it ill-formed in \cite{P2900R8} for a contract assertion to trigger an implicit lambda capture.

\subsection{Do not refer to moved-from \tcode{const} parameters}

On the one hand, exposing the moved-from parameter value in \tcode{post} is the ``honest'' choice, as it simply reflects what is going on under the hood. On the other hand, it exposes an implementation detail of C++ coroutines to the caller that is currently not being exposed. This not only violates the principle that the coroutine-ness of a function should be an implementation detail, but is also likely to be surprising to the user, and can lead to unexpected behaviour and unintended bugs that will be very difficult to diagnose.

Furthermore, it does not seem useful to be able to write a postcondition on a parameter that can be moved-from, as we cannot reason about the meaning of such a postcondition, in the same way in which we cannot reason about the meaning of a postcondition on a parameter that is not \tcode{const} (which \cite{P2900R8} makes ill-formed for that reason).

It is therefore a reasonable design goal to avoid this scenario. Solution 5c directly violates this design goal.
%JMB: 5b violates it too, and relies on what is often not considered a semantic change in a type to decide that it "works" anyway.   Even if there's no move constructor, you are still unquestionably using an object that has been moved-from as a non-const xvalue to initialize another object, and not consistently applying the rule that we don't we the value of such objects is confusing.

%TD: I don't agree with this characterisation. If your type doesn't have a non-trivial move constructor, there is literally no way to "move-from" an object of this type, as this operation does not exist for this type, so moved-from values cannot exist either. Note that `int i = 42; int j = std::move(i);` is exactly equivalent to `int i = 42; int j = i;` and it is guaranteed by the Standard that it is exactly equivalent. Same for non-trivial types that have a user-provided copy constructor but no move constructor: the Standard guarantees that when you try to move-from, what actually happens is a normal copy. So I don't see how 5b violates this design goal, and I don't see how your statement "you are still unquestionably using an object that has been moved-from" can be true for those types.

%JMB: The fact that a trivially moveable thign leaves its moved-from object in an empty state is just the result of an optimization --- it's still moved-from.   `int` might promise not to change the source when doing a move, but my type that happens to be trivially movable today shouldn't ever be beholden to that promise going forward just becuase a memcpy suffices today.
% If I write this code:
%   void f(T t)
%   {
%       g(std::move(t));
%       h(std::move(t));
%   }
% Your response should be "that's broken", not "that's OK if T happens to be trivially movable".
%
% THis is the same thing.

% TD: I think this is a purely philosophical debate. My reply to your code above is indeed "that's OK if T happens to be trivially movable" because that's just what falls out of the current specification. I suggest we don't spend more time on this here as whether or not 5b gets a green mark or a red cross in this row is pretty much irrelevant, because we are already discarding 5b as a viable solution due to it violating the "do not facilitate remote code breakage" design goal. Are you OK with leaving this discussion be for now, in the interest of getting the paper out sooner?

\subsection{Do not introduce additional inconsistencies between \tcode{pre} and \tcode{post}}

A well-designed Contracts feature will naturally compose with other C++ language features, including coroutines. We should avoid adding more complexity to make Contracts and coroutines work together. In particular, we should avoid introducing new inconsistencies between \tcode{pre} and \tcode{post} that do not exist in the current design, as that could be surprising to the user and hinder effective usage and wider adoption of Contracts.

Arguably, Solution 2 violates this design goal, because it would introduce the notion that not all kinds of function contract assertions can apply to all functions. Being able to apply \tcode{pre}, but not \tcode{post} to a function is arguably surprising.

Solution 4 also violates this design goal. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same function parameter, then the corresponding \emph{id-expression} will refer to the same parameter object with the same address. Solution 5c breaks this symmetry, which can lead to unexpected consequences.

Finally, Solution 5c violates this design goal because an \emph{id-expression} referring to the same parameter might see different values in \tcode{pre} and \tcode{post}, respectively, even if the parameter in question is \tcode{const}. This is highly unintuitive and cannot happen with \tcode{pre} and \tcode{post} as specified in \cite{P2900R8} today.

Note that Solution 3 does not violate this design goal because it does not introduce a new inconsistency. One of the necessary limitations of \tcode{post}, compared to \tcode{pre}, is that it is ill-formed to refer to non-reference parameters in the predicate of \tcode{post} that might have been modified in the function body, as that would make it impossible for the caller to reason about the postcondition. In \cite{P2900R8}, this applies to non-\tcode{const} parameters. Solution 3 extends this to \tcode{const} parameters in a coroutine, as those parameters may be moved from and are thus effectively never \tcode{const}, even if declared as such. Solution 3 therefore applies the existing Contracts design to coroutines in a consistent way.

\subsection{Do not facilitate remote code breakage}

Our design for how Contracts and coroutines work together should not facilitate situations that can lead to unintended, remote code breakage. Solution 5b violates this design goal because it would create a new dependency between the trivial movability of a type and the ability to use it as a function parameter.

For example, if the user adds a move constructor to a type that previously only had a copy constructor (something that we explicitly encourage people to do to modernise their code!), this will break clients who happen to use this type as a coroutine parameter. Likewise, if there is a struct with an \tcode{int} and a \tcode{float} data member, and the user adds a \tcode{std::string} data member, this will also break clients who happen to use this type as a coroutine parameter. Such breakage would happen for highly non-obvious reasons, does not have a good workaround (at least not until we get postcondition captures as a post-MVP extensions), and therefore seems user-hostile.

\subsection{Support caller-side checking of \tcode{post}}

The Contracts MVP has been designed from the start to accommodate a wide range of implementation strategies and usage scenarios. In particular, it allows implementations to check precondition and postcondition assertions caller-side and/or callee-side, and enables the two translation units involved to make the decision on contract evaluation semantics independently.

In particular, if one has deployed a pre-built library with all contracts ignored, and the user of that pre-built library wishes to verify that it is working correctly when used from particular other translation units, enabling caller-side checking of that library's precondition and postcondition assertions can be very useful, for example to validate a new version of such a library before integrating it into the shipping product. In general, any time we cross the boundary between translation units, it is very helpful (and currently intentionally supported by \cite{P2900R8}) to have both sides of that boundary be able to enable contract checks.

However, in order to be able to enable caller-side postcondition checks, the predicate of \tcode{post} cannot depend on anything that is not accessible caller-side and only known callee-side. For coroutines, it means that \tcode{post} cannot refer to the coroutine frame copies of parameter objects. Solution 4 is therefore not compatible with caller-side checking of \tcode{post}.


\section{Proposed solution}

Having formulated our design goals, we can now construct a decision matrix that visualises which possible solutions in the available design space satisfy which design goals:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\yes}{\includegraphics[width=4mm]{images/yes.png}}
\newcommand{\no}{\includegraphics[width=4mm]{images/no.png}}
%\vspace{4mm}
\begin{table}[!h]
\begin{tabular}{|p{6.7cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|}
\hline 
 & $1$ & $2$ & $3$ & $4$ & $5$a & $5$b & $5$c  \\
\hline
Allow \tcode{pre} on coroutines & \no & \yes & \yes & \yes & \yes & \yes & \yes  \\
\hline
Allow \tcode{post} on coroutines  & \no & \no & \yes & \yes & \yes & \yes & \yes  \\
\hline
Satisfy Contracts Prime Directive & \yes & \yes & \yes & \no & \no & \yes & \yes  \\
\hline
Do not expose moved-from parameters & \yes & \yes & \yes & \yes  & \yes & \yes & \no  \\
\hline
Do not make \tcode{pre}/\tcode{post} more inconsistent & \yes & \no & \yes & \no & \no & \yes & \no \\
\hline
Do not facilitate remote code breakage & \yes & \yes & \yes & \yes & \yes & \no & \yes \\
\hline
Support caller-side checking of \tcode{post} & \yes & \yes & \yes & \no & \yes & \yes & \yes  \\
\hline
\end{tabular}
\vspace{2mm}
\label{table:matrix}
\end{table}

The decision matrix reveals that the only possible solution that satisfies all our design goals is Solution 3: allow \tcode{pre} and \tcode{post} on coroutines, but make it ill-formed to odr-use a parameter of a coroutine in \tcode{post} (even if that parameter is \tcode{const}). Therefore, we propose to adopt Solution 3 for the Contracts MVP. We are convinced that this is the best option for the C++ language and its users.

Note that with Solution 3, if it is really necessary to refer to the function parameters in the postcondition, a workaround exists: one can wrap the coroutine into a non-coroutine wrapper as shown in Section \ref{intro}. With such a wrapper, the user themselves has to make the choice whether to copy or move a parameter, and there is no question as to whether \tcode{post} applies to the original or copy of the parameter, as only the original is visible to the wrapper. The situation will become even simpler once we get postcondition captures \cite{P3098R0} as a post-MVP extension, as parameters can be explicitly copied for later use in the postcondition, and the need for a wrapper will go away.

\section{Proposed wording}

The proposed wording is relative to \cite{P2900R8}.

Modify [dcl.contract.func], paragraph 6:
\begin{adjustwidth}{0.5cm}{0.5cm}
A \removed{coroutine ([dcl.fct.def.coroutine]), }a deleted function ([dcl.fct.def.delete])\removed{,} or a function defaulted on its first declaration ([dcl.fct.def.default]) may not have a \emph{function-contract-specifier-seq}.
\end{adjustwidth}

Modify [dcl.contract.func], paragraph 8:
\begin{adjustwidth}{0.5cm}{0.5cm}
If the predicate of a postcondition assertion of a function odr-uses ([basic.def.odr]) \added{a parameter of that function, the function shall not be a coroutine ([dcl.fct.def.coroutine]); if that parameter is not a reference, it }\removed{a non-reference parameter of that function, that parameter} shall be declared \tcode{const} and shall not have array or function type.
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 9:
\begin{adjustwidth}{0.5cm}{0.5cm}
An implementation may need to allocate additional storage for a coroutine. This storage is known as the \emph{coroutine state} and is obtained by calling a non-array allocation function ([basic.stc.dynamic.allocation])\added{ as part of the replacement body}. The allocation function's name is looked up by searching for it in the scope of the promise type.
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 13:
\begin{adjustwidth}{0.5cm}{0.5cm}
When a coroutine is invoked, \removed{after initializing its parameters ([expr.call])}\added{at the beginning of the replacement body}, a copy is created for each coroutine parameter. For a parameter of type $cv$ \tcode{T}, the copy is a variable of type $cv$ \tcode{T} with automatic storage duration that is direct-initialized from an xvalue of type \tcode{T} referring to the parameter.
\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
% TODO - nothing here yet

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Replace ToC entry for bibliography by custom one
%\addtocontents{toc}{\protect\numberline{}} % Blank line in ToC
\addcontentsline{toc}{section}{\protect\numberline{}Bibliography} %Manual ToC entry
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

